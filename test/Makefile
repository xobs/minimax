TESTS := $(basename $(wildcard test_*.S)) $(basename $(wildcard test_*.c))

FUSESOC ?= fusesoc
FUSESOC_TOOL ?= ghdl
IVERILOG ?= iverilog
VVP ?= vvp

PYTHON ?= python3
CROSS_COMPILE ?= riscv64-unknown-elf-
CROSS_CC ?= $(CROSS_COMPILE)gcc
CROSS_OBJCOPY ?= $(CROSS_COMPILE)objcopy

CFLAGS := -march=rv32ic -mabi=ilp32	\
	  -fno-pic -nostartfiles -nostdlib

LDFLAGS := -march=rv32ic -mabi=ilp32	\
	   -fno-pic -Wl,--no-relax	\
	   -nostartfiles -nostdlib

default: dirs $(addsuffix /pass, $(TESTS)) $(addsuffix /pass.verilog, $(TESTS))

dirs:
	-@mkdir -p $(TESTS)

VPATH=../asm

clean:
	rm -rf *.o $(TESTS)

.PHONY: default clean dirs $(TESTS)
.PRECIOUS: %.o %/minimax.rom %/a.out

# Make each test case try to generate a "pass" file
.SECONDEXPANSION:
$(TESTS): dirs $$@/pass $$@/pass.verilog

# ...the "pass" file is generated by a successful simulation result
%/pass: %/minimax.rom ../rtl/minimax.vhd ../rtl/minimax_tb.vhd
	-@mkdir -p $*
	-@if [ ! -e $*/fusesoc.conf ]; then cd $* && fusesoc library add minimax ../..; fi
	cd $* && \
		$(FUSESOC) run --target=sim --tool=$(FUSESOC_TOOL) minimax	\
			--MAXTICKS=100000					\
			--ROM_FILENAME=minimax.rom > log
	touch $@

# ...the "pass" file is generated by a successful simulation result
%/pass.verilog: %/minimax.rom ../rtl/minimax.v ../rtl/minimax_tb.v
	-@mkdir -p $*
	cd $* && \
		$(IVERILOG) -o test-harness.vvp \
			-DCOMPATIBLE_TRACE \
			-DENABLE_ASSERTS \
			-DENABLE_TRACE \
			-DENABLE_REGISTER_INSPECTION \
			-DROM_FILENAME='"minimax.rom"' \
			-DSKIP_MICROCODE \
			../../rtl/minimax_tb.v ../../rtl/minimax.v \
		&& \
		$(VVP) -N ./test-harness.vvp > log.verilog.raw
# Massage the resulting error output so that it looks similar to fusesoc output
# Note that this is required because Verilog's `$display()` has no ability to
# print in all-caps, whereas fusesoc prints in capitals.
	cat $*/log.verilog.raw | sed '/^WARNING: /d' | sed '/^ERROR: /d' | sed '/^VCD info: /d' | LC_ALL=C awk 'NR==1 {print $$0} NR>1 {print toupper($$0)}' > $*/log.verilog
	touch $@

# .mem generator
%/minimax.rom: %/a.out
	$(CROSS_OBJCOPY) -O binary $< $@.bin
	$(PYTHON) ../asm/bin2mem $@.bin $@

# Linker
%/a.out: %.o microcode.o
	$(CROSS_CC) $(LDFLAGS) -T ../asm/bare.ld -o $@ $^

# Assembler
%.o: %.S
	$(CROSS_CC) $(CFLAGS) -c -o $@ \
		-DTEST_FUNC_NAME=$* -DTEST_FUNC_TXT='"$*"' -DTEST_FUNC_RET=$*_ret $<

# Compiler
%.o: %.c
	$(CROSS_CC) $(CFLAGS) -Os -c -o $@ $<
